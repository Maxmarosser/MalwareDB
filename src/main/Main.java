package main;

import static java.nio.file.StandardCopyOption.*;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.NamedQuery;
import javax.persistence.Persistence;
import javax.persistence.Query;
import javax.persistence.TypedQuery;

import com.sun.xml.internal.bind.v2.TODO;

import database.Malware;

public class Main {
    private static final String PERSISTENCE_UNIT_NAME = "malware";
    private static String databasePath = "";
    private static String storagePath = "";
    private static String databaseUser = "";
    private static String databasePassword = "";
    private static String databaseDriver = "org.apache.derby.jdbc.EmbeddedDriver";
    private static String databasePathPrefix = "jdbc:derby:";
    private static String databasePathSuffix = ";create=true";

    private static EntityManagerFactory factory;
    private static EntityManager em;

    public static void main(String[] args) {
	// System.out.println(args.length);
	// -mv /home/wojtyla/workspaceEclipse/MalwareDB/from/aaa

	// dbquery();

	loadConfigFile();
	startDatabaseCon();

	// overwriteConfigFile();

	System.exit(0);

	if ((args.length <= 1) || (args[0].contentEquals("-h"))) {
	    help();
	    System.exit(0);
	}
	if (((args.length == 2))) {
	    String op = "";
	    try {
		op = args[0];
		Path file = Paths.get(args[1]);
		FileInputStream fis = new FileInputStream(file.toFile());
		fis.close();
	    } catch (FileNotFoundException e) {
		System.out.println("File not found.");
	    } catch (IOException e) {
		System.out.println("File not found.");
	    }

	    Path file = Paths.get(args[1]);
	    String name = file.getFileName().toString();
	    String md5hash = md5Convertion(file);
	    String sha1hash = sha1Convertion(file);
	    String location = storagePath + md5hash;

	    // database connection init
	    startDatabaseCon();

	    // check whether the malware is in DB, if yes, the name of the file
	    // is added
	    if (!isFileAlreadyKnown(md5hash, sha1hash, name)) {
		switch (op) {
		case "-mv":
		    // operation move
		    System.out.println("Operation move");

		    System.out.println("MD5 hascode: " + md5hash);
		    System.out.println("SHA1 hascode: " + sha1hash);

		    createRecordInDatabase(md5hash, sha1hash, location, name);
		    moveFile(file, md5hash);

		    break;
		case "-cp":
		    // operation copy
		    System.out.println("Operation copy");

		    System.out.println("MD5 hascode: " + md5hash);
		    System.out.println("SHA1 hascode: " + sha1hash);

		    createRecordInDatabase(md5hash, sha1hash, location, name);
		    copyFile(file, md5hash);
		    break;
		default:
		    help();
		    break;
		}
	    }
	} else {
	    help();
	}

	dbquery();
	stopDatabaseCon();
	System.exit(0);

    }

    /**
     * It loads properties from config file madab.conf which is in root
     * directory of the project
     */
    private static void loadConfigFile() {
	Properties prop = new Properties();

	try {
	    // load a properties file
	    prop.load(new FileInputStream("madab.config"));

	    databasePath = prop.getProperty("databasePath");
	    storagePath = prop.getProperty("storagePath");
	    databaseUser = prop.getProperty("databaseUser");
	    databasePassword = prop.getProperty("databasePassword");
	    System.out.println(databasePath);
	} catch (IOException ex) {
	    ex.printStackTrace();
	}
    }

    /**
     * It overwrites properties from config file madab.conf which is in root
     * directory of the project
     */
    private static void overwriteConfigFile() {
	String comments = "Configuration file for madab.jar application: \n \n";
	Properties prop = new Properties();

	try {
	    // set the properties value
	    prop.setProperty("storagePath", "/home/wojtyla/workspaceEclipse/MalwareDB/MalwareStorage/");
	    prop.setProperty("databasePath", "/home/wojtyla/workspaceEclipse/MalwareDB/databases/MalwareDB/");
	    prop.setProperty("databaseUser", "madab");
	    prop.setProperty("databasePassword", "madab");

	    // save properties to project root folder
	    prop.store(new FileOutputStream("madab.config"), comments);

	} catch (IOException ex) {
	    ex.printStackTrace();
	}

    }

    /**
     * Connection to database is created
     */
    private static void startDatabaseCon() {
	try {
	    Map<String, String> properties = new HashMap<String, String>();
	    properties.put("javax.persistence.jdbc.driver", databaseDriver);
	    properties.put("javax.persistence.jdbc.url", databasePathPrefix + databasePath+ databasePathSuffix);
	    properties.put("javax.persistence.jdbc.user", databaseUser);
	    properties.put("javax.persistence.jdbc.password", databasePassword);
	    factory = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME, properties);

	    em = factory.createEntityManager();

	    // just to try if schema, username, a table exist
	    Query q = em.createQuery("select m from Malware m");
	    System.out.println(q.getResultList());

	} catch (Exception e) {
	    System.out.println("Unable to connect to database. Check database path, username or password. Please try again.");
	    // e.printStackTrace();
	    System.exit(0);
	}

    }

    /**
     * Connection to database is closed
     */
    private static void stopDatabaseCon() {
	em.close();
	factory.close();
    }

    /**
     * it goes all records in database and check if the md5hash and sha1hash is
     * already presented if yes, the name is added to column titles and it
     * return true if not, false is returned
     * 
     * @param md5hash
     * @param sha1hash
     */
    private static boolean isFileAlreadyKnown(String md5hash, String sha1hash, String name) {
	// Query q = em.createQuery("select m from Malware m");
	em.getTransaction().begin();
	Query tquery = em.createQuery("select m from Malware m", Malware.class);

	List<Malware> list = tquery.getResultList();

	for (Iterator<Malware> iterator = list.iterator(); iterator.hasNext();) {
	    Malware malware = (Malware) iterator.next();

	    // TODO Auto-generated method stub
	    // if one of them md5 or sha1 is same and the other ones are
	    // different, ALLERT
	    // MD5 ADN SHA1 should be always both same with tested subject or
	    // both negative
	    if ((md5hash.contentEquals(malware.getMd5hash()))) {
		System.out.println("malware already presented in database.");
		malware.addTitle(name);

		em.merge(malware);

		em.getTransaction().commit();
		return true;
	    }
	}
	return false;
    }

    /**
     * Random query for database content.
     */
    private static void dbquery() {
	EntityManagerFactory factory = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME);
	EntityManager em = factory.createEntityManager();

	em.getTransaction().begin();
	Query q = em.createQuery("select m from Malware m");

	System.out.println(q.getResultList());

	em.getTransaction().commit();
	em.close();
	factory.close();
    }

    /**
     * tries to connect to database and handle requests
     */
    private static void createRecordInDatabase(String md5, String sha1, String location, String name) {
	// ./ij
	// connect
	// 'jdbc:derby:/home/wojtyla/workspaceEclipse/databases/MalwareDB';
	// show tables;
	// disconnect;

	EntityManagerFactory factory = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME);
	EntityManager em = factory.createEntityManager();

	em.getTransaction().begin();

	Malware temp = new Malware();
	temp.setMd5hash(md5);
	temp.setSha1hash(sha1);
	temp.setLocation(storagePath + md5);
	temp.addTitle(name);

	em.persist(temp);

	em.getTransaction().commit();
	em.close();
	factory.close();
    }

    private static void help() {
	System.out.println("madab -arg1 -arg2 path file");
	System.out.println("-mv - move malware to DB");
	System.out.println("-cp - copy malware to DB");

    }

    /*
     * it moves the file to storage location and rename it with md5 hash
     * existing file is overwritten
     */
    private static void moveFile(Path file, String md5hash) {
	Path target = Paths.get(storagePath, md5hash);
	try {
	    Files.move(file, target, REPLACE_EXISTING);
	} catch (IOException e) {
	    e.printStackTrace();
	}

    }

    private static void copyFile(Path file, String md5hash) {
	Path target = Paths.get(storagePath, md5hash);
	try {
	    Files.copy(file, target, REPLACE_EXISTING);
	} catch (IOException e) {
	    e.printStackTrace();
	}

    }

    /*
     * Function calculate md5 hash of given file
     */
    public static String md5Convertion(Path file) {
	try {
	    MessageDigest md = MessageDigest.getInstance("MD5");

	    FileInputStream fis = new FileInputStream(file.toFile());

	    byte[] dataBytes = new byte[9999];

	    int read = 0;

	    while ((read = fis.read(dataBytes)) != -1) {
		md.update(dataBytes, 0, read);
	    }
	    ;

	    byte[] mdbytes = md.digest();

	    StringBuffer hexString = new StringBuffer();
	    for (int i = 0; i < mdbytes.length; i++) {
		String hex = Integer.toHexString(0xff & mdbytes[i]);
		if (hex.length() == 1)
		    hexString.append('0');
		hexString.append(hex);
	    }

	    fis.close();
	    return hexString.toString();

	} catch (NoSuchAlgorithmException e) {
	    e.printStackTrace();
	} catch (FileNotFoundException e) {
	    e.printStackTrace();
	} catch (IOException e) {
	    e.printStackTrace();
	}
	return "0";

    }

    /*
     * Function calculate sha1 hash of given file
     */
    private static String sha1Convertion(Path file) {
	try {
	    MessageDigest md = MessageDigest.getInstance("SHA1");

	    FileInputStream fis = new FileInputStream(file.toFile());

	    byte[] dataBytes = new byte[9999];

	    int read = 0;

	    while ((read = fis.read(dataBytes)) != -1) {
		md.update(dataBytes, 0, read);
	    }
	    ;

	    byte[] mdbytes = md.digest();

	    StringBuffer hexString = new StringBuffer();
	    for (int i = 0; i < mdbytes.length; i++) {
		String hex = Integer.toHexString(0xff & mdbytes[i]);
		if (hex.length() == 1)
		    hexString.append('0');
		hexString.append(hex);
	    }

	    fis.close();
	    return hexString.toString();

	} catch (NoSuchAlgorithmException e) {
	    e.printStackTrace();
	} catch (FileNotFoundException e) {
	    e.printStackTrace();
	} catch (IOException e) {
	    e.printStackTrace();
	}
	return "-1";

    }

}
