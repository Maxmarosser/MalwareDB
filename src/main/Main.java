package main;

import static java.nio.file.StandardCopyOption.*;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.NamedQuery;
import javax.persistence.Persistence;
import javax.persistence.Query;
import javax.persistence.TypedQuery;

import com.sun.xml.internal.bind.v2.TODO;

import database.Malware;

public class Main {
	private static final String PERSISTENCE_UNIT_NAME = "malware";
	public static String storagePath = ("/home/wojtyla/workspaceEclipse/MalwareDB/MalwareStorage/");

	private static EntityManagerFactory factory;
	private static EntityManager em;

	public static void main(String[] args) {
		// System.out.println(args.length);
		// -mv /home/wojtyla/workspaceEclipse/MalwareDB/from/aaa

		// dbquery();
		// System.exit(0);

		if ((args.length <= 1) && (args[0].contentEquals("-h"))) {
			help();
			System.exit(0);
		}
		if (((args.length == 2))) {
			String op = "";
			try {
				op = args[0];
				Path file = Paths.get(args[1]);
				FileInputStream fis = new FileInputStream(file.toFile());
				fis.close();
			} catch (FileNotFoundException e) {
				System.out.println("File not found.");
			} catch (IOException e) {
				System.out.println("File not found.");
			}

			Path file = Paths.get(args[1]);
			String name = file.getFileName().toString();
			String md5hash = md5Convertion(file);
			String sha1hash = sha1Convertion(file);
			String location = storagePath + md5hash;

			//database connection init
			startDatabaseCon();
			
			//check whether the malware is in DB, if yes, the name of the file is added
			if (!isFileAlreadyKnown(md5hash, sha1hash, name)) {			
				switch (op) {
				case "-mv":
					//operation move
					System.out.println("Operation move");

					System.out.println("MD5 hascode: " + md5hash);
					System.out.println("SHA1 hascode: " + sha1hash);

					database(md5hash, sha1hash, location, name);
					moveFile(file, md5hash);

					break;
				case "-cp":
					//operation copy
					System.out.println("Operation copy");

					System.out.println("MD5 hascode: " + md5hash);
					System.out.println("SHA1 hascode: " + sha1hash);

					database(md5hash, sha1hash, location, name);
					copyFile(file, md5hash);
					break;
				default:
					help();
					break;
				}
			}
		} else {
			help();
		}

		dbquery();
		stopDatabaseCon();
		System.exit(0);

	}

	/**
	 * Connection to database is created
	 */
	private static void startDatabaseCon() {
		factory = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME);
		try {
			em = factory.createEntityManager();
		} catch (IllegalStateException e) {
			System.out.println("Unable to connect to database!");
			System.exit(0);
		}
		

	}

	/**
	 * Connection to database is closed
	 */
	private static void stopDatabaseCon() {
		em.close();
		factory.close();
	}

	/**
	 * it goes all records in database and check if the md5hash and sha1hash is
	 * already presented if yes, the name is added to column titles and it
	 * return true if not, false is returned
	 * 
	 * @param md5hash
	 * @param sha1hash
	 */
	private static boolean isFileAlreadyKnown(String md5hash, String sha1hash,
			String name) {
		// Query q = em.createQuery("select m from Malware m");
		em.getTransaction().begin();
		Query tquery = em.createQuery(
				"select m from Malware m", Malware.class);

		List<Malware> list = tquery.getResultList();

		for (Iterator<Malware> iterator = list.iterator(); iterator.hasNext();) {
			Malware malware = (Malware) iterator.next();

			// TODO Auto-generated method stub
			// if one of them md5 or sha1 is same and the other ones are
			// different, ALLERT
			// MD5 ADN SHA1 should be always both same with tested subject or
			// both negative
			if ((md5hash.contentEquals(malware.getMd5hash()))) {
				System.out.println("malware already presented in database.");
				malware.addTitle(name);
				
				em.merge(malware);

				em.getTransaction().commit();
				return true;
			}
		}
		return false;
	}

	private static void dbquery() {
		EntityManagerFactory factory = Persistence
				.createEntityManagerFactory(PERSISTENCE_UNIT_NAME);
		EntityManager em = factory.createEntityManager();

		em.getTransaction().begin();
		Query q = em.createQuery("select m from Malware m");

		System.out.println(q.getResultList());

		em.getTransaction().commit();
		em.close();
		factory.close();
	}

	/**
	 * tries to connect to database and handle requests
	 */
	private static void database(String md5, String sha1, String location,
			String name) {
		// ./ij
		// connect
		// 'jdbc:derby:/home/wojtyla/workspaceEclipse/databases/MalwareDB';
		// show tables;
		// disconnect;

		EntityManagerFactory factory = Persistence
				.createEntityManagerFactory(PERSISTENCE_UNIT_NAME);
		EntityManager em = factory.createEntityManager();

		em.getTransaction().begin();

		Malware temp = new Malware();
		temp.setMd5hash(md5);
		temp.setSha1hash(sha1);
		temp.setLocation(storagePath + md5);
		temp.addTitle(name);

		em.persist(temp);

		em.getTransaction().commit();
		em.close();
		factory.close();
	}

	private static void help() {
		System.out.println("madab -arg1 -arg2 path file");
		System.out.println("-mv - move malware to DB");
		System.out.println("-cp - copy malware to DB");

	}

	/*
	 * it moves the file to storage location and rename it with md5 hash
	 * existing file is overwritten
	 */
	private static void moveFile(Path file, String md5hash) {
		Path target = Paths.get(storagePath, md5hash);
		try {
			Files.move(file, target, REPLACE_EXISTING);
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	private static void copyFile(Path file, String md5hash) {
		Path target = Paths.get(storagePath, md5hash);
		try {
			Files.copy(file, target, REPLACE_EXISTING);
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	/*
	 * Function calculate md5 hash of given file
	 */
	public static String md5Convertion(Path file) {
		try {
			MessageDigest md = MessageDigest.getInstance("MD5");

			FileInputStream fis = new FileInputStream(file.toFile());

			byte[] dataBytes = new byte[9999];

			int read = 0;

			while ((read = fis.read(dataBytes)) != -1) {
				md.update(dataBytes, 0, read);
			}
			;

			byte[] mdbytes = md.digest();

			StringBuffer hexString = new StringBuffer();
			for (int i = 0; i < mdbytes.length; i++) {
				String hex = Integer.toHexString(0xff & mdbytes[i]);
				if (hex.length() == 1)
					hexString.append('0');
				hexString.append(hex);
			}

			fis.close();
			return hexString.toString();

		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return "0";

	}

	/*
	 * Function calculate sha1 hash of given file
	 */
	private static String sha1Convertion(Path file) {
		try {
			MessageDigest md = MessageDigest.getInstance("SHA1");

			FileInputStream fis = new FileInputStream(file.toFile());

			byte[] dataBytes = new byte[9999];

			int read = 0;

			while ((read = fis.read(dataBytes)) != -1) {
				md.update(dataBytes, 0, read);
			}
			;

			byte[] mdbytes = md.digest();

			StringBuffer hexString = new StringBuffer();
			for (int i = 0; i < mdbytes.length; i++) {
				String hex = Integer.toHexString(0xff & mdbytes[i]);
				if (hex.length() == 1)
					hexString.append('0');
				hexString.append(hex);
			}

			fis.close();
			return hexString.toString();

		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return "-1";

	}

}
