package main;

import static java.nio.file.StandardCopyOption.*;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.NamedQuery;
import javax.persistence.Persistence;
import javax.persistence.Query;
import javax.persistence.TypedQuery;

import com.sun.xml.internal.bind.v2.TODO;

import database.Malware;

public class Main {
    private static final String PERSISTENCE_UNIT_NAME = "malware";
    private static String databasePath = "";
    private static String storagePath = "";
    private static String databaseUser = "";
    private static String databasePassword = "";
    private static String databaseDriver = "org.apache.derby.jdbc.EmbeddedDriver";
    private static String databasePathPrefix = "jdbc:derby:";
    private static String databasePathSuffix = ";create=true";

    private static EntityManagerFactory factory;
    private static EntityManager em;

    public static void main(String[] args) {
	if ((args.length <= 1) || (args[0].contentEquals("-h"))) {
	    help();
	    System.exit(0);
	}

	// System.out.println(args.length);
	// -mv /home/wojtyla/workspaceEclipse/MalwareDB/from/aaa

	// dbquery();

	loadConfigFile();
	startDatabaseCon();

	// overwriteConfigFile();

	// System.exit(0);

	String op = args[0];

	switch (op) {
	case "-mv":
	    // operation move
	    System.out.println("Operation move");
	    operationMoveOrCopy(args);
	    break;
	case "-cp":
	    // operation copy
	    System.out.println("Operation copy");
	    operationMoveOrCopy(args);
	    break;
	case "-s":
	    System.out.println("Search mode");
	    searchMode(args);
	    break;
	default:
	    help();
	    break;
	}

    }

    private static void operationMoveOrCopy(String[] args) {

	String op = "";
	try {
	    op = args[0];
	    Path file = Paths.get(args[1]);
	    FileInputStream fis = new FileInputStream(file.toFile());
	    fis.close();
	} catch (Exception e) {
	    System.out.println("File not found or corrupted.");
	    System.exit(0);
	}

	Path file = Paths.get(args[1]);
	String name = file.getFileName().toString();
	String md5hash = md5Convertion(file);
	String sha1hash = sha1Convertion(file);
	String location = storagePath + md5hash;

	// check whether the malware is in DB, if yes, the name of the file
	// is added
	if (!isFileAlreadyKnown(md5hash, sha1hash, name)) {
	    switch (op) {
	    case "-mv":
		// operation move
		System.out.println("MD5 hascode: " + md5hash);
		System.out.println("SHA1 hascode: " + sha1hash);

		createRecordInDatabase(md5hash, sha1hash, location, name);
		moveFile(file, md5hash);

		break;
	    case "-cp":
		// operation copy
		System.out.println("MD5 hascode: " + md5hash);
		System.out.println("SHA1 hascode: " + sha1hash);

		createRecordInDatabase(md5hash, sha1hash, location, name);
		copyFile(file, md5hash);
		break;
	    }
	}
	dbquery();
	stopDatabaseCon();
	System.exit(0);
    }

    private static void searchMode(String[] args) {
	String op1 = "", op2 = "";
	try {
	    op1 = args[1];
	    op2 = args[2];
	} catch (Exception e) {
	    help();
	    System.exit(0);
	}
	switch (op1) {
	case "-md5":
	    Query q = em.createQuery("select m from Malware m where m.md5hash like :op2", Malware.class).setParameter("op2", op2);
	    List<Malware> list = q.getResultList();
	    System.out.println(list);
	    break;
	case "-sha1":
	    Query qq = em.createQuery("select m from Malware m where m.sha1hash like :op2", Malware.class).setParameter("op2", op2);
	    List<Malware> list2 = qq.getResultList();
	    System.out.println(list2);
	    break;
	case "-n":
	    Query qqq = em.createQuery("select m from Malware m where m.titles like '%"+op2+"%'", Malware.class);
	    //Query qqq = em.createQuery("select m from Malware m where m.titles like op2", Malware.class).setParameter("op2", "'%"+op2+"%'");
	    List<Malware> list3 = qqq.getResultList();
	    System.out.println(list3);
	    break;
	default:
	    help();
	    break;
	}

    }

    /**
     * It loads properties from config file madab.conf which is in root
     * directory of the project
     */
    private static void loadConfigFile() {
	Properties prop = new Properties();

	try {
	    // load a properties file
	    prop.load(new FileInputStream("madab.config"));

	    databasePath = prop.getProperty("databasePath");
	    storagePath = prop.getProperty("storagePath");
	    databaseUser = prop.getProperty("databaseUser");
	    databasePassword = prop.getProperty("databasePassword");

	} catch (IOException ex) {
	    System.out.println("Unable to load config file.");
	    System.exit(0);
	    // ex.printStackTrace();
	}
    }

    /**
     * It overwrites properties from config file madab.conf which is in root
     * directory of the project
     */
    private static void overwriteConfigFile() {
	String comments = "Configuration file for madab.jar application: \n \n";
	Properties prop = new Properties();

	try {
	    // set the properties value
	    prop.setProperty("storagePath", "/home/wojtyla/workspaceEclipse/MalwareDB/MalwareStorage/");
	    prop.setProperty("databasePath", "/home/wojtyla/workspaceEclipse/MalwareDB/databases/MalwareDB/");
	    prop.setProperty("databaseUser", "madab");
	    prop.setProperty("databasePassword", "madab");

	    // save properties to project root folder
	    prop.store(new FileOutputStream("madab.config"), comments);

	} catch (IOException ex) {
	    ex.printStackTrace();
	}

    }

    /**
     * Connection to database is created
     */
    private static void startDatabaseCon() {
	try {
	    Map<String, String> properties = new HashMap<String, String>();
	    properties.put("javax.persistence.jdbc.driver", databaseDriver);
	    properties.put("javax.persistence.jdbc.url", databasePathPrefix + databasePath + databasePathSuffix);
	    properties.put("javax.persistence.jdbc.user", databaseUser);
	    properties.put("javax.persistence.jdbc.password", databasePassword);
	    factory = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME, properties);

	    em = factory.createEntityManager();

	    // just to try if schema, username, a table exist
	    Query q = em.createQuery("select m from Malware m");

	} catch (Exception e) {
	    System.out.println("Unable to connect to database. Check database path, username or password. Please try again.");
	    // e.printStackTrace();
	    System.exit(0);
	}

    }

    /**
     * Connection to database is closed
     */
    private static void stopDatabaseCon() {
	em.close();
	factory.close();
    }

    /**
     * it goes all records in database and check if the md5hash and sha1hash is
     * already presented if yes, the name is added to column titles and it
     * return true if not, false is returned
     * 
     * @param md5hash
     * @param sha1hash
     */
    private static boolean isFileAlreadyKnown(String md5hash, String sha1hash, String name) {
	// Query q = em.createQuery("select m from Malware m");
	em.getTransaction().begin();
	Query tquery = em.createQuery("select m from Malware m", Malware.class);

	List<Malware> list = tquery.getResultList();

	for (Iterator<Malware> iterator = list.iterator(); iterator.hasNext();) {
	    Malware malware = (Malware) iterator.next();

	    // TODO Auto-generated method stub
	    // if one of them md5 or sha1 is same and the other ones are
	    // different, ALLERT
	    // MD5 ADN SHA1 should be always both same with tested subject or
	    // both negative
	    if ((md5hash.contentEquals(malware.getMd5hash()))) {
		System.out.println("malware already presented in database.");
		malware.addTitle(name);

		em.merge(malware);

		em.getTransaction().commit();
		return true;
	    }
	}
	return false;
    }

    /**
     * Random query for database content.
     */
    private static void dbquery() {

	em.getTransaction().begin();
	Query q = em.createQuery("select m from Malware m");

	System.out.println(q.getResultList());

	em.getTransaction().commit();
    }

    /**
     * tries to connect to database and handle requests
     */
    private static void createRecordInDatabase(String md5, String sha1, String location, String name) {
	// ./ij
	// connect
	// 'jdbc:derby:/home/wojtyla/workspaceEclipse/databases/MalwareDB';
	// show tables;
	// disconnect;

	// EntityManagerFactory factory =
	// Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME);
	em = factory.createEntityManager();

	em.getTransaction().begin();

	Malware temp = new Malware();
	temp.setMd5hash(md5);
	temp.setSha1hash(sha1);
	temp.setLocation(storagePath + md5);
	temp.addTitle(name);

	em.persist(temp);

	em.getTransaction().commit();
    }

    private static void help() {
	System.out.println("madab:");
	System.out.println("-mv /file - move malware to DB");
	System.out.println("-cp /file - copy malware to DB");
	System.out.println("-s -md5 /file - search for a malware by md5 hash");
	System.out.println("-s -sha1 /file - search for a malware by sha1 hash");
	System.out.println("-s -name /file - search for a malware by name hash");

    }

    /*
     * it moves the file to storage location and rename it with md5 hash
     * existing file is overwritten
     */
    private static void moveFile(Path file, String md5hash) {
	Path target = Paths.get(storagePath, md5hash);
	try {
	    Files.move(file, target, REPLACE_EXISTING);
	} catch (IOException e) {
	    e.printStackTrace();
	}

    }

    private static void copyFile(Path file, String md5hash) {
	Path target = Paths.get(storagePath, md5hash);
	try {
	    Files.copy(file, target, REPLACE_EXISTING);
	} catch (IOException e) {
	    e.printStackTrace();
	}

    }

    /*
     * Function calculate md5 hash of given file
     */
    public static String md5Convertion(Path file) {
	try {
	    MessageDigest md = MessageDigest.getInstance("MD5");

	    FileInputStream fis = new FileInputStream(file.toFile());

	    byte[] dataBytes = new byte[9999];

	    int read = 0;

	    while ((read = fis.read(dataBytes)) != -1) {
		md.update(dataBytes, 0, read);
	    }
	    ;

	    byte[] mdbytes = md.digest();

	    StringBuffer hexString = new StringBuffer();
	    for (int i = 0; i < mdbytes.length; i++) {
		String hex = Integer.toHexString(0xff & mdbytes[i]);
		if (hex.length() == 1)
		    hexString.append('0');
		hexString.append(hex);
	    }

	    fis.close();
	    return hexString.toString();

	} catch (Exception e) {
	    // e.printStackTrace();
	    System.out.println("Problem with file occured, check the file.");
	}
	return "0";

    }

    /*
     * Function calculate sha1 hash of given file
     */
    private static String sha1Convertion(Path file) {
	try {
	    MessageDigest md = MessageDigest.getInstance("SHA1");

	    FileInputStream fis = new FileInputStream(file.toFile());

	    byte[] dataBytes = new byte[9999];

	    int read = 0;

	    while ((read = fis.read(dataBytes)) != -1) {
		md.update(dataBytes, 0, read);
	    }
	    ;

	    byte[] mdbytes = md.digest();

	    StringBuffer hexString = new StringBuffer();
	    for (int i = 0; i < mdbytes.length; i++) {
		String hex = Integer.toHexString(0xff & mdbytes[i]);
		if (hex.length() == 1)
		    hexString.append('0');
		hexString.append(hex);
	    }

	    fis.close();
	    return hexString.toString();

	} catch (NoSuchAlgorithmException e) {
	    e.printStackTrace();
	} catch (FileNotFoundException e) {
	    e.printStackTrace();
	} catch (IOException e) {
	    e.printStackTrace();
	}
	return "-1";

    }

}
