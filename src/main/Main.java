package main;

/*
 Copyright (c) 2013 Vojtech Uhlir | Sebastian Garcia | FEE CVUT agents.felk.cvut.cz @2013
 vojtech.uhlir@agents.fel.cvut.cz
 sebastian.garcia@agents.fel.cvut.cz

 Software Madab for managing binary files through database.

 Used libraries:
 Database Apache Derby, an Apache DB subproject, is an open source relational database implemented entirely in Java and available under the Apache License, Version 2.0.
 The Apache Commons CLI library provides an API for parsing command line options passed to programs.

 Github repository https://github.com/WojtylaCZ/MalwareDB @20.8.2013

 The Software shall be used for Good, not Evil. ;)
 */

import static java.nio.file.StandardCopyOption.*;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.DirectoryNotEmptyException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import javax.persistence.TypedQuery;

import org.apache.commons.cli.*;

import database.Malware;

public class Main {
    private static final String PERSISTENCE_UNIT_NAME = "malware";
    private static String databasePath = "";
    private static String storagePath = "";
    private static String databaseUser = "";
    private static String databasePassword = "";
    private static String databaseDriver = "org.apache.derby.jdbc.EmbeddedDriver";
    private static String databasePathPrefix = "jdbc:derby:";
    private static String databasePathSuffix = ";create=true";
    private static boolean debugMode = false;

    private static EntityManagerFactory factory;
    private static EntityManager em;

    private static Options options;

    private static final String help = "h";
    private static final String debug = "d";
    private static final String config = "f";
    private static final String index = "i";
    private static final String copy = "c";
    private static final String search = "s";
    private static final String wholeDB = "w";
    private static final String addStatus = "t";

    private static final String md5p = "md5";
    private static final String sha1p = "sha1";
    private static final String namep = "name";
    private static final String hoursp = "hours";

    public static void main(String[] args) {
	// Apache Commons cli library for easier usage of program parameters
	options = setupOptions();
	CommandLineParser parser = new PosixParser();
	CommandLine cmdLine = null;

	if (args.length == 0) {
	    help();
	}

	// cmdLine is variable from the CLI library storing all the parameters
	try {
	    cmdLine = parser.parse(options, args);
	} catch (ParseException e) {
	    System.out.println(e.getMessage());
	    help();
	}

	if (cmdLine.hasOption(help)) {
	    help();
	}
	if (cmdLine.hasOption(debug)) {
	    debugMode = true;
	    System.out.println("Debug mode of madab.");
	}

	if (!cmdLine.hasOption(config)) {
	    if (debugMode == true)
		System.out.println("Conf path needs to be setup.");
	    System.exit(0);
	}
	String[] confFilePath = cmdLine.getOptionValues(config);
	loadConfigFile(confFilePath[0]);
	startDatabaseCon();

	if (cmdLine.hasOption(wholeDB)) {
	    wholeDbQuery();
	}

	if (cmdLine.hasOption(index)) {
	    if (debugMode == true)
		System.out.println("Operation index.");

	    operationMoveOrCopy(index, cmdLine.getOptionValue(index));

	} else if (cmdLine.hasOption(copy)) {
	    if (debugMode == true)
		System.out.println("Operation copy.");

	    operationMoveOrCopy(copy, cmdLine.getOptionValue(copy));

	} else if (cmdLine.hasOption(addStatus)) {
	    if (debugMode == true)
		System.out.println("Add status operation.");

	    String[] statusParam = cmdLine.getOptionValues(addStatus);
	    if (statusParam.length == 2) {
		if (statusParam[1].contains(",")) {
		    System.out.println("Status can not contain comma character! See --help.");		  
		} else {
		    addStatus(statusParam[0], statusParam[1]);

		}
	    } else {
		System.out.println("See --help for values.");
		help();
	    }

	} else if (cmdLine.hasOption(search)) {
	    if (debugMode == true)
		System.out.println("Search mode.");

	    // Search mode needs to have two values
	    String[] searchParam = cmdLine.getOptionValues(search);
	    if (searchParam.length == 2) {
		searchMode(searchParam[0], searchParam[1]);
	    } else {
		System.out.println("See --help for value.");
		help();
	    }

	} else {
	    System.out.println("See --help for parameters.");
	    help();
	}
	// just for safety in any case the db connection should be closed,
	stopDatabaseCon();
	if (debugMode == true)
	    System.out.println("Db connection closed.");
	System.exit(0);

    }

    /**
     * Setup of all parameters
     * 
     * @return options which is settings for parameters
     */
    private static Options setupOptions() {
	// create Options object
	Options options = new Options();

	options.addOption(help, "help", false, "How to control madab.");
	options.addOption(debug, "debug", false, "Run madab in debug mode.");
	options.addOption(wholeDB, "wholedb", false, "Madab prints whole content of database.");

	OptionBuilder.withLongOpt("index");
	OptionBuilder.withArgName("file");
	OptionBuilder.hasArg(true);
	OptionBuilder
		.withDescription("It indexes the binary, it adds record to database and it moves the file to malware storage. If the binary is already known, file is deleted.");
	Option move = OptionBuilder.create(index);
	options.addOption(move);

	OptionBuilder.withLongOpt("copy");
	OptionBuilder.withArgName("file");
	OptionBuilder.hasArg();
	OptionBuilder.withDescription("It indexes also the binary, but the binary is not in any circumstences deleted from original location.");
	Option copyy = OptionBuilder.create(copy);
	options.addOption(copyy);

	OptionBuilder.withLongOpt("search");
	OptionBuilder.withDescription("Search for a binary in database by md5 or sha1 hash, by name of a file or by last <value> hours.");
	OptionBuilder.hasArgs(2);
	OptionBuilder.withArgName("md5|sha1|name|hours> <value");
	Option searchh = OptionBuilder.create(search);
	options.addOption(searchh);

	OptionBuilder.withLongOpt("conf");
	OptionBuilder.withDescription("madab.conf configuration file.");
	OptionBuilder.hasArg(true);
	OptionBuilder.hasArgs(1);
	OptionBuilder.withArgName("file");
	Option conf = OptionBuilder.create(config);
	options.addOption(conf);

	OptionBuilder.withLongOpt("addStatus");
	OptionBuilder.hasArgs(2);
	OptionBuilder.withArgName("md5> <\"status\"");
	OptionBuilder
		.withDescription("Put md5 hash and string, which you want to add as status. String has to be bordered by \"\" and can not contain commas.");
	Option addstat = OptionBuilder.create(addStatus);
	options.addOption(addstat);

	return options;

    }

    /**
     * Help prints whole setting of parameters necessary for the madab
     */
    private static void help() {
	HelpFormatter formatter = new HelpFormatter();
	formatter.printHelp("madab.jar", options, true);
	System.exit(0);
    }

    /**
     * For file index(move) or copy is necessary arg differencing the action and
     * path where the file is placed
     * 
     * @param arg
     * @param filePath
     */
    private static void operationMoveOrCopy(String arg, String filePath) {
	Path file = null;
	Long fileSize = 0L;
	try {
	    // get a binary file
	    file = Paths.get(filePath);
	    // get a size of the binary file
	    fileSize = Files.size(file);
	} catch (Exception e) {
	    System.out.println("File not found or corrupted." + " Log: " + e.getMessage());
	    System.exit(0);
	}

	// get a name of the binary
	String name = file.getFileName().toString();

	// suffix is last sequence of characters after a last dot
	int suffixIndex = name.lastIndexOf(".");
	String suffix = "";
	if (suffixIndex != -1) {
	    suffix = name.substring(suffixIndex);
	}

	// get a md5 hash
	String md5hash = md5Convertion(file);
	// get a sha1hash
	String sha1hash = sha1Convertion(file);
	// create a path in file storage to the binary
	String location = storagePath + md5hash + suffix;
	// mark it with actual date in millis
	Long dateInMillis = Calendar.getInstance().getTimeInMillis();

	/*
	 * check whether the malware is in DB, if not, file is moved to malware
	 * storage and a record is created in database if yes, the name of the
	 * file is added in DB and file is deleted
	 */

	if (!isFileAlreadyKnown(md5hash, sha1hash, name)) {
	    switch (arg) {
	    case index:
		// operation move
		if (debugMode == true) {
		    System.out.println("MD5 hascode: " + md5hash);
		    System.out.println("SHA1 hascode: " + sha1hash);
		}

		createRecordInDatabase(md5hash, sha1hash, location, name, fileSize, dateInMillis);
		moveFile(file, md5hash, suffix);
		System.out.println(location + "   " + name + "   " + " MOVED.");
		break;
	    case copy:
		// operation copy
		if (debugMode == true) {
		    System.out.println("MD5 hascode: " + md5hash);
		    System.out.println("SHA1 hascode: " + sha1hash);
		}
		createRecordInDatabase(md5hash, sha1hash, location, name, fileSize, dateInMillis);
		copyFile(file, md5hash, suffix);
		System.out.println(location + "   " + name + " COPIED.");
		break;
	    }
	} else {
	    /*
	     * if the malware is known, the name is added to the database and
	     * the actual file is removed from users folder
	     */
	    switch (arg) {
	    case index:
		deleteFile(file);
	    }

	}

	// it prints content of database
	// wholeDbQuery();

	stopDatabaseCon();
	if (debugMode == true)
	    System.out.println("Operation closed, db connection closed.");
	System.exit(0);
    }

    /**
     * Search mode needs to have op1 - over what to search - md5, sha1, name,
     * date ; op2 - actual value
     * 
     * @param op1
     * @param op2
     */
    private static void searchMode(String op1, String op2) {
	switch (op1) {
	case md5p:
	    TypedQuery<Malware> q = em.createQuery("select m from Malware m where m.md5hash like :op2", Malware.class).setParameter("op2", op2);
	    List<Malware> list = q.getResultList();
	    if (list.size() == 1) {
		System.out.print(list.get(0));
	    } else if (list.size() == 0) {
	    } else {
		System.out.println("There is more than one output! Attention!");
		System.out.print(list);
	    }
	    break;
	case sha1p:
	    TypedQuery<Malware> qq = em.createQuery("select m from Malware m where m.sha1hash like :op2", Malware.class).setParameter("op2", op2);
	    List<Malware> list2 = qq.getResultList();
	    if (list2.size() == 1) {
		System.out.print(list2.get(0));
	    } else if (list2.size() == 0) {
	    } else {
		System.out.println("There is more than one output! Attention!");
		System.out.print(list2);
	    }
	    break;
	case namep:
	    TypedQuery<Malware> qqq = em.createQuery("select m from Malware m where m.names like '%" + op2 + "%'", Malware.class);
	    // Query qqq =
	    // em.createQuery("select m from Malware m where m.titles like op2",
	    // Malware.class).setParameter("op2", "'%"+op2+"%'");
	    List<Malware> list3 = qqq.getResultList();
	    for (Iterator<Malware> iterator = list3.iterator(); iterator.hasNext();) {
		Malware malware = (Malware) iterator.next();
		System.out.print(malware);
	    }

	    break;
	case hoursp:
	    // it returns last op2 hours (which are multiplied to milliseconds
	    // and subtracted from actual time)
	    try {
		Long interval = (Calendar.getInstance().getTimeInMillis()) - (Long.parseLong(op2) * 60 * 60 * 1000);
		TypedQuery<Malware> qqqq = em.createQuery("select m from Malware m where m.dateInMillis >=" + String.valueOf(interval), Malware.class);
		List<Malware> list4 = qqqq.getResultList();
		for (Iterator<Malware> iterator = list4.iterator(); iterator.hasNext();) {
		    Malware malware = (Malware) iterator.next();
		    System.out.print(malware);
		}
	    } catch (Exception e) {
		System.out.println("Wrong number format." + " Log: " + e.getMessage());
		System.exit(0);
	    }

	    break;
	default:
	    help();
	    break;
	}

    }

    /**
     * To add status is possible by identification of record by md5 and string
     * where is the actual text
     * 
     * @param md5
     * @param status
     */
    public static void addStatus(String md5, String status) {
	em.getTransaction().begin();
	TypedQuery<Malware> q = em.createQuery("select m from Malware m where m.md5hash like :op", Malware.class).setParameter("op", md5);
	List<Malware> list = q.getResultList();
	if (list.size() == 1) {
	    Malware temp = list.get(0);
	    temp.setStatus("\"" + status + "\"");

	    em.merge(temp);

	} else if (list.size() == 0) {
	    System.out.println("No record found to add status.");
	} else {
	    System.out.println("There is more than one output! Attention!");
	    System.out.print(list);
	}
	em.getTransaction().commit();
    }

    /**
     * It loads properties from config file madab.conf which is in specified
     * path
     * 
     * @param path
     */
    private static void loadConfigFile(String path) {
	Properties prop = new Properties();

	try {
	    // load a properties file
	    prop.load(new FileInputStream(path));

	    databasePath = prop.getProperty("databasePath");
	    storagePath = prop.getProperty("storagePath");
	    databaseUser = prop.getProperty("databaseUser");
	    databasePassword = prop.getProperty("databasePassword");

	    if (debugMode == true)
		System.out.println("Conf file of madab sucessfully loaded.");
	} catch (IOException ex) {
	    System.out.println("Unable to load config file." + " Log: " + ex.getMessage());
	    System.exit(0);
	    // ex.printStackTrace();
	}
    }

    /**
     * It overwrites properties from config file madab.conf which is in root
     * directory of the project
     */
    @SuppressWarnings("unused")
    private static void overwriteConfigFile() {
	String comments = "Configuration file for madab.jar application: \n \n";
	Properties prop = new Properties();

	try {
	    // set the properties value
	    prop.setProperty("storagePath", "/home/wojtyla/workspaceEclipse/MalwareDB/MalwareStorage/");
	    prop.setProperty("databasePath", "/home/wojtyla/workspaceEclipse/MalwareDB/databases/MalwareDB/");
	    prop.setProperty("databaseUser", "madab");
	    prop.setProperty("databasePassword", "madab");

	    // save properties to project root folder
	    prop.store(new FileOutputStream("madab.config"), comments);

	} catch (IOException ex) {
	    System.out.println("Unable to write a config file." + " Log: " + ex.getMessage());
	    // ex.printStackTrace();
	}

    }

    /**
     * Connection to database is created
     */
    private static void startDatabaseCon() {
	try {
	    Map<String, String> properties = new HashMap<String, String>();
	    properties.put("javax.persistence.jdbc.driver", databaseDriver);
	    properties.put("javax.persistence.jdbc.url", databasePathPrefix + databasePath + databasePathSuffix);
	    properties.put("javax.persistence.jdbc.user", databaseUser);
	    properties.put("javax.persistence.jdbc.password", databasePassword);
	    factory = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME, properties);

	    em = factory.createEntityManager();

	    // just to try if schema, username, a table exist
	    @SuppressWarnings("unused")
	    TypedQuery<Malware> q = em.createQuery("select m from Malware m", Malware.class);

	    if (debugMode == true)
		System.out.println("Database successfully connected.");

	} catch (Exception e) {
	    System.out.println("Unable to connect to database. Check database path, username or password. Please try again." + " Log: " + e.getMessage());
	    System.out.println("Madab automaticaly creates a folder for the database. Do not create it.");
	    // e.printStackTrace();
	    System.exit(0);
	}

    }

    /**
     * Connection to database is closed
     */
    private static void stopDatabaseCon() {
	try {
	    em.close();
	    factory.close();
	} catch (Exception e) {
	    System.out.println("DB was not properly initialized." + e.getMessage());
	    System.exit(0);
	}

    }

    /**
     * it goes all records in database and check if the md5hash and sha1hash is
     * already presented if yes, the name is added to column titles and it
     * return true if not, false is returned
     * 
     * @param md5hash
     * @param sha1hash
     */
    private static boolean isFileAlreadyKnown(String md5hash, String sha1hash, String name) {
	em.getTransaction().begin();
	TypedQuery<Malware> tquery = em.createQuery("select m from Malware m", Malware.class);

	List<Malware> list = tquery.getResultList();

	for (Iterator<Malware> iterator = list.iterator(); iterator.hasNext();) {
	    Malware malware = (Malware) iterator.next();

	    // if one of them md5 or sha1 is same and the other ones are
	    // different, ALLERT
	    // MD5 ADN SHA1 should be always both same with tested subject or
	    // both negative
	    if (md5hash.contentEquals(malware.getMd5hash()) && (!(sha1hash.contentEquals(malware.getSha1hash())))) {
		System.out.println("ALERT! The MD5 hash is same but sha1 hash is different!!!");
	    }
	    if ((md5hash.contentEquals(malware.getMd5hash()))) {
		System.out.println(name + " already known as <MD5>: " + md5hash);
		malware.addName(name);

		em.merge(malware);

		em.getTransaction().commit();
		return true;
	    }
	}
	return false;
    }

    /**
     * Query to print whole content of database.
     */
    private static void wholeDbQuery() {

	TypedQuery<Malware> q = em.createQuery("select m from Malware m", Malware.class);

	List<Malware> list = q.getResultList();
	for (Iterator<Malware> iterator = list.iterator(); iterator.hasNext();) {
	    Malware malware = (Malware) iterator.next();
	    System.out.print(malware);
	}
	stopDatabaseCon();
	if (debugMode == true)
	    System.out.println("Operation closed, db connection closed.");
	System.exit(0);

    }

    /**
     * tries to connect to database and handle requests
     */
    private static void createRecordInDatabase(String md5, String sha1, String location, String name, Long sizeInBytes, Long timestampInMillis) {
	// ./ij
	// connect
	// 'jdbc:derby:/home/wojtyla/workspaceEclipse/databases/MalwareDB';
	// show tables;
	// disconnect;
	em = factory.createEntityManager();

	em.getTransaction().begin();

	Malware temp = new Malware();
	temp.setMd5hash(md5);
	temp.setSha1hash(sha1);
	temp.setLocation(location);
	temp.addName(name);
	temp.setSizeInBytes(sizeInBytes);
	temp.setDateInMillis(timestampInMillis);

	em.persist(temp);

	em.getTransaction().commit();
    }

    /*
     * it deletes the file from user's location
     */

    private static void deleteFile(Path file) {
	try {
	    Files.deleteIfExists(file);
	} catch (DirectoryNotEmptyException e2) {
	    System.out.println("File is a non-empty directory and cannot be deleted." + " Log: " + e2.getMessage());
	} catch (IOException e) {
	    System.out.println("File could not be removed." + " Log: " + e.getMessage());
	}

    }

    /*
     * it moves the file to storage location and rename it with md5 hash
     * existing file is overwritten
     */
    private static void moveFile(Path file, String md5hash, String suffix) {
	Path target = Paths.get(storagePath, md5hash + suffix);
	try {
	    Files.move(file, target, REPLACE_EXISTING);
	} catch (IOException e) {
	    System.out.println("Unable to move the file." + " Log: " + e.getMessage());
	    // e.printStackTrace();
	}

    }

    /*
     * it copy the malware file
     */

    private static void copyFile(Path file, String md5hash, String suffix) {
	Path target = Paths.get(storagePath, md5hash + suffix);
	try {
	    Files.copy(file, target, REPLACE_EXISTING);
	} catch (IOException e) {
	    System.out.println("Unable to copy the file" + " Log: " + e.getMessage());
	    // e.printStackTrace();
	}

    }

    /*
     * Function calculate md5 hash of given file
     */
    public static String md5Convertion(Path file) {
	try {
	    MessageDigest md = MessageDigest.getInstance("MD5");

	    FileInputStream fis = new FileInputStream(file.toFile());

	    byte[] dataBytes = new byte[9999];

	    int read = 0;

	    while ((read = fis.read(dataBytes)) != -1) {
		md.update(dataBytes, 0, read);
	    }
	    ;

	    byte[] mdbytes = md.digest();

	    StringBuffer hexString = new StringBuffer();
	    for (int i = 0; i < mdbytes.length; i++) {
		String hex = Integer.toHexString(0xff & mdbytes[i]);
		if (hex.length() == 1)
		    hexString.append('0');
		hexString.append(hex);
	    }

	    fis.close();
	    return hexString.toString();

	} catch (Exception e) {
	    // e.printStackTrace();
	    System.out.println("Problem with file occured, unable to do a md5 hash, check the file." + " Log: " + e.getMessage());
	}
	return "0";

    }

    /*
     * Function calculate sha1 hash of given file
     */
    private static String sha1Convertion(Path file) {
	try {
	    MessageDigest md = MessageDigest.getInstance("SHA1");

	    FileInputStream fis = new FileInputStream(file.toFile());

	    byte[] dataBytes = new byte[9999];

	    int read = 0;

	    while ((read = fis.read(dataBytes)) != -1) {
		md.update(dataBytes, 0, read);
	    }
	    ;

	    byte[] mdbytes = md.digest();

	    StringBuffer hexString = new StringBuffer();
	    for (int i = 0; i < mdbytes.length; i++) {
		String hex = Integer.toHexString(0xff & mdbytes[i]);
		if (hex.length() == 1)
		    hexString.append('0');
		hexString.append(hex);
	    }

	    fis.close();
	    return hexString.toString();

	} catch (Exception e) {
	    // e.printStackTrace();
	    System.out.println("Problem with file occured, unable to do a sha1 hash, check the file." + " Log: " + e.getMessage());
	}
	return "-1";

    }

}
